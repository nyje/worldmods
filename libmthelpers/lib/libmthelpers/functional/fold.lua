--[[
variations on left-fold over a "generator"
(standing in for lazy lists from haskell etc.)
and an initial value.
returns a result object containing either the end folded value or an error.

note that the generator uses the deferral pattern for iterators;
generator must satisfy the usage
for err, element1[, element2 ...] in generator() do block end
the err argument is used to indicate generator stop.
if it is nil, iteration stops.
if it is non-nil *but* isn't "true", this indicates an error occurred.
in this case, an error result containing this value is produced.
]]

--[[
This variant allows the fold function to indicate an error,
by returning a non-nil first value.

Note that in general in lua,
there is no way to determine the #args a function takes,
so it is up to the caller to determine whether generator's iterator
returns an appropriate amount of values to the caller.

Also note the loadstring tricks we're doing here.
One can't write a construct like "for ... in iterator() do block end".
Therefore, the caller requests the variant that they wish to use.
loadstring is used to generate the specialisation,
and memoization is used to cache them.

For consistency's sake, the error value comes first from the generator,
then the n results come after.
(In the n=1 case, this is backwards from the usual lua pattern.)
The fold function will always be passed the current state
(the left-hand part of the fold, the "accumulator")
followed by these n results from the generator if it did not indicate an error.

the fold function's *return values* instead follow the usual convention,
of result followed by error.
]]
local result = mtrequire("com.github.thetaepsilon.minetest.libmthelpers.functional.result")
local rpcall = result.rpcall

local i = {}



local var_memos = { "v1" }
local function mk_var_r(n)
	if n < 1 then error("recursion underflow!") end

	local m = var_memos[n]
	if m then return m end
	-- else we have two paths.
	-- the base n=1 case, and the cases above that separated by ", ".

	if n == 1 then return "v1" end

	-- else we are > 1, so concat with n-1
	local v = mk_var_r(n-1) .. ", v" .. tostring(n)
	var_memos[n] = v
	return v
end

-- make the n-arg string for the variables in efold$n,
-- as well as a few other uses below.
local stupid_size = 32
local stupid_error = "why do you need a variant for more than "..stupid_size.." values!?"
local mk_var_string = function(n)
	-- gotta stop somewhere, I guess...
	if n > stupid_size then
		error(stupid_error)
	end
	return mk_var_r(n)
end



-- error object generation helper for the functions generated by genefoldn.
local etype = {
	EGENFAIL = true,
	EFOLDERFAIL = true,
}
i.error_types = etype

local ehelper = function(e, isgen)
	local err

	if isgen then
		err = {
			type = "EGENFAIL",
			explain = function(self)
				return "Fold aborted due to generator error"
			end,
		}
	else
		err = {
			type = "EFOLDERFAIL",
			explain = function(self)
				return "Fold aborted due to fold function error"
			end,
		}
	end
	err.causedby = e

	return result.err(err)
end



local genefoldn = function(n)
	local desc = "efoldl<"..tostring(n)..">()"
	local vars = mk_var_string(n)
	local src = table.concat({
		-- extract injected ok and err constructors from the varargs.
		"local ok, ehelper = ...",
		"return function(gen, fold, initial)",
		"	local state = initial",
		"	for status, "..vars.." in gen() do",
		"		if status ~= true then return ehelper(status, true) end",
		"		local y, err = fold(state, "..vars..")",
		"		if err then ehelper(err, false) end",
		"		state = y",
		"	end",
		"	return ok(state)",
		"end",
	}, "\n")
	--[[
	print("-- begin gen: "..desc)
	print(src)
	print("-- end gen: "..desc)
	]]
	local f, err = loadstring(src, desc)
	if not f then error("genefoldn(): loadstring failed: "..err) end
	return f(result.ok, ehelper)
end



local memos = {}
local function efoldln(n)
	local f = memos[n]
	if not f then
		f = genefoldn(n)
		memos[n] = f
	end
	return f
end
i.efoldln = efoldln



-- array iterator helper for use with foldl.
-- produces a generator which returns the values 1-n from an array-like table.
-- so like ipairs() but discarding the index (and returning a generator status),
-- so one can just write a fold function with just state and next inputs.
-- note this generator makes no attempt to catch errors arising from table accesses.
local index = function(self, ...)
	local i = self.i
	local l = self.l

	i = i + 1
	if i > l then
		--print("-- end of array")
		return nil, nil
	end

	local v = self.t[i]

	self.i = i
	--print(i)
	--print(v)
	return true, v
end
-- for-loop constructor, use as: for err, v in avalues(list) do ...
local avalues = function(tbl, len)
	len = len or #tbl
	--print("avalues(): len = "..len)
	local self = {
		i = 0,
		l = len,
		t = tbl,
	}
	return index, self
end
i.avalues = avalues

-- "delay" version of the above.
-- unfornately we cannot efficiently do the following:
--[[
local delay = function(f, ...)
	return function()
		return f(...)
	end
end
]]
-- however, a value-based delay may still be useful for clients.
local delay = function(v)
	return function()
		return v
	end
end
i.delay = delay

-- use like: = foldl(agen(tbl), foldop, initialv)
local agen = function(tbl, len)
	return function()
		return avalues(tbl, len)
	end
end
i.agen = agen

-- nil generator.
local nilgen = function() end
local ngen = delay(delay(nilgen))
i.ngen = ngen



-- some common binary infix operators in function form (non-exhaustive...)
local op = {}
-- warning: assumption that add is associative.
-- this may break if input objects have e.g. __add metamethods.
-- if metamethods are desired it is highly recommended to use a dedicated fold function,
-- to avoid surprising behaviour with e.g.
-- the second object's metamethod being used instead of the first.
op.add = function(s, a) return s + a end
-- beware, subtraction is not associative
op.subl = function(s, a) return a - s end
op.subr = function(s, a) return s - a end
op.mult = function(s, a) return s * a end
op.concat = function(s, a) return s .. a end

i.op = op




return i

